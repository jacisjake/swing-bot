"""
Signal processor.

Validates signals, applies risk checks, and calculates position sizes.
"""

from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from src.bot.config import BotConfig
from src.bot.signals.base import Signal, SignalDirection
from src.core.regime_detector import RegimeDetector
from src.risk.portfolio_limits import PortfolioLimits, TradingAction
from src.risk.position_sizer import PositionSizer


@dataclass
class TradeParams:
    """
    Parameters for executing a trade.

    Generated by SignalProcessor after all validations pass.
    """
    symbol: str
    side: str  # "buy" or "sell"
    quantity: float
    entry_price: float
    stop_price: float
    target_price: Optional[float]
    order_type: str  # "market" or "limit"
    time_in_force: str  # "day" or "gtc"
    signal: Signal
    extended_hours: bool = False

    @property
    def is_crypto(self) -> bool:
        return "/" in self.symbol or self.symbol.endswith("USD")

    def to_dict(self) -> dict:
        return {
            "symbol": self.symbol,
            "side": self.side,
            "quantity": self.quantity,
            "entry_price": self.entry_price,
            "stop_price": self.stop_price,
            "target_price": self.target_price,
            "order_type": self.order_type,
            "time_in_force": self.time_in_force,
            "signal_strength": self.signal.strength,
            "strategy": self.signal.strategy,
            "extended_hours": self.extended_hours,
        }


@dataclass
class ProcessResult:
    """Result of signal processing."""
    passed: bool
    trade_params: Optional[TradeParams]
    rejection_reason: Optional[str]
    warnings: list[str]


class SignalProcessor:
    """
    Process signals through risk checks and position sizing.

    Steps:
    1. Validate signal quality (strength, R:R ratio)
    2. Check portfolio limits
    3. Calculate position size
    4. Return trade parameters or rejection
    """

    def __init__(
        self,
        config: BotConfig,
        position_sizer: PositionSizer,
        portfolio_limits: PortfolioLimits,
        regime_detector: Optional[RegimeDetector] = None,
    ):
        """
        Initialize signal processor.

        Args:
            config: Bot configuration
            position_sizer: Position sizing calculator
            portfolio_limits: Portfolio risk limits
            regime_detector: Optional HMM regime detector for market-level gating
        """
        self.config = config
        self.position_sizer = position_sizer
        self.portfolio_limits = portfolio_limits
        self.regime_detector = regime_detector

    # PDT limit: brokers block the 4th day trade in 5 days for margin accounts under $25K
    PDT_MAX_DAY_TRADES = 3

    def process(
        self,
        signal: Signal,
        account_equity: float,
        buying_power: float,
        current_positions: int,
        daytrade_count: int = 0,
    ) -> ProcessResult:
        """
        Process a signal through all validations.

        Args:
            signal: Trading signal to process
            account_equity: Current account equity
            buying_power: Available buying power
            current_positions: Number of open positions
            daytrade_count: Rolling 5-day day trade count from broker

        Returns:
            ProcessResult with trade params or rejection reason
        """
        warnings = []

        # Step 0: PDT guard â€” don't enter if we can't exit same-day
        if account_equity < 25_000 and daytrade_count >= self.PDT_MAX_DAY_TRADES:
            return ProcessResult(
                passed=False,
                trade_params=None,
                rejection_reason=f"PDT protection: {daytrade_count} day trades used (max {self.PDT_MAX_DAY_TRADES} for accounts under $25K)",
                warnings=warnings,
            )

        # Step 1: Validate signal quality
        rejection = self._check_signal_quality(signal)
        if rejection:
            return ProcessResult(
                passed=False,
                trade_params=None,
                rejection_reason=rejection,
                warnings=warnings,
            )

        # Step 2: Check portfolio limits
        self.portfolio_limits.update_equity(account_equity)
        limits_check = self.portfolio_limits.check_can_open_position(
            current_equity=account_equity,
            current_positions=current_positions,
        )
        if not limits_check.passed:
            return ProcessResult(
                passed=False,
                trade_params=None,
                rejection_reason=f"Portfolio limits: {limits_check.message}",
                warnings=warnings,
            )
        if limits_check.action == TradingAction.REDUCE_ONLY:
            warnings.append(f"Warning: {limits_check.message}")

        # Step 3: Calculate position size
        # Use momentum sizing for day trading (majority of buying power)
        max_bp_pct = getattr(self.config, 'max_position_pct_of_buying_power', 0.90)
        size_result = self.position_sizer.calculate_momentum_size(
            account_equity=account_equity,
            entry_price=signal.entry_price,
            stop_price=signal.stop_price,
            buying_power=buying_power,
            max_equity_pct=max_bp_pct,
        )

        if size_result.shares < 0.001:  # Effectively zero
            return ProcessResult(
                passed=False,
                trade_params=None,
                rejection_reason=f"Position too small: {size_result.shares:.4f} shares",
                warnings=warnings,
            )

        if size_result.capped_by_buying_power:
            warnings.append(f"Position capped by buying power: {size_result.shares:.4f} shares")

        if size_result.capped_by_max_position:
            warnings.append(f"Position capped by max position limit: {size_result.shares:.4f} shares")

        # Determine if extended hours are needed
        now = datetime.now()
        current_hour = now.hour
        current_minute = now.minute
        
        # Simple market hours check (9:30 - 16:00)
        is_market_hours = (
            (current_hour > 9 or (current_hour == 9 and current_minute >= 30)) and
            (current_hour < 16)
        )
        
        use_extended_hours = self.config.enable_extended_hours and not is_market_hours
        
        # Force limit orders during extended hours
        order_type = "market"
        if use_extended_hours:
            order_type = "limit"
        
        trade_params = TradeParams(
            symbol=signal.symbol,
            side="buy" if signal.direction == SignalDirection.LONG else "sell",
            quantity=size_result.shares,
            entry_price=signal.entry_price,
            stop_price=signal.stop_price,
            target_price=signal.target_price,
            order_type=order_type,  # Adjusted for extended hours
            time_in_force="gtc" if signal.is_crypto else "day",
            signal=signal,
            extended_hours=use_extended_hours,
        )

        return ProcessResult(
            passed=True,
            trade_params=trade_params,
            rejection_reason=None,
            warnings=warnings,
        )

    def _check_signal_quality(self, signal: Signal) -> Optional[str]:
        """
        Check signal meets quality thresholds.

        Returns rejection reason or None if passed.
        """
        # Check regime gate (market-level filter)
        if (
            self.config.enable_regime_gate
            and self.regime_detector is not None
            and self.regime_detector.trained
        ):
            if self.regime_detector.is_bearish():
                status = self.regime_detector.get_status()
                return (
                    f"Regime gate: {status['label']} ({status['category']}, "
                    f"{status['confidence']:.0%} confidence)"
                )

        # Check if shorting is allowed
        if signal.direction.value == "short" and not self.config.allow_short_selling:
            return "Short selling disabled"

        # Check strength
        if signal.strength < self.config.min_signal_strength:
            return f"Signal too weak: {signal.strength:.2f} < {self.config.min_signal_strength}"

        # Check R:R ratio (use small epsilon for floating point comparison)
        if signal.risk_reward_ratio:
            if signal.risk_reward_ratio < self.config.min_risk_reward - 0.01:
                return f"R:R too low: {signal.risk_reward_ratio:.2f} < {self.config.min_risk_reward}"

        # Check risk percent isn't too high
        # Allow wider stops for low-priced volatile stocks (up to 15%)
        max_stop_pct = 0.15
        if signal.risk_percent > max_stop_pct:
            return f"Stop too wide: {signal.risk_percent:.1%} risk (max {max_stop_pct:.0%})"

        return None
