"""
Signal processor.

Validates signals, applies risk checks, and calculates position sizes.
"""

from dataclasses import dataclass
from typing import Optional

from src.bot.config import BotConfig
from src.bot.signals.base import Signal, SignalDirection
from src.risk.portfolio_limits import PortfolioLimits, TradingAction
from src.risk.position_sizer import PositionSizer


@dataclass
class TradeParams:
    """
    Parameters for executing a trade.

    Generated by SignalProcessor after all validations pass.
    """
    symbol: str
    side: str  # "buy" or "sell"
    quantity: float
    entry_price: float
    stop_price: float
    target_price: Optional[float]
    order_type: str  # "market" or "limit"
    time_in_force: str  # "day" or "gtc"
    signal: Signal

    @property
    def is_crypto(self) -> bool:
        return "/" in self.symbol or self.symbol.endswith("USD")

    def to_dict(self) -> dict:
        return {
            "symbol": self.symbol,
            "side": self.side,
            "quantity": self.quantity,
            "entry_price": self.entry_price,
            "stop_price": self.stop_price,
            "target_price": self.target_price,
            "order_type": self.order_type,
            "time_in_force": self.time_in_force,
            "signal_strength": self.signal.strength,
            "strategy": self.signal.strategy,
        }


@dataclass
class ProcessResult:
    """Result of signal processing."""
    passed: bool
    trade_params: Optional[TradeParams]
    rejection_reason: Optional[str]
    warnings: list[str]


class SignalProcessor:
    """
    Process signals through risk checks and position sizing.

    Steps:
    1. Validate signal quality (strength, R:R ratio)
    2. Check portfolio limits
    3. Calculate position size
    4. Return trade parameters or rejection
    """

    def __init__(
        self,
        config: BotConfig,
        position_sizer: PositionSizer,
        portfolio_limits: PortfolioLimits,
    ):
        """
        Initialize signal processor.

        Args:
            config: Bot configuration
            position_sizer: Position sizing calculator
            portfolio_limits: Portfolio risk limits
        """
        self.config = config
        self.position_sizer = position_sizer
        self.portfolio_limits = portfolio_limits

    def process(
        self,
        signal: Signal,
        account_equity: float,
        buying_power: float,
        current_positions: int,
    ) -> ProcessResult:
        """
        Process a signal through all validations.

        Args:
            signal: Trading signal to process
            account_equity: Current account equity
            buying_power: Available buying power
            current_positions: Number of open positions

        Returns:
            ProcessResult with trade params or rejection reason
        """
        warnings = []

        # Step 1: Validate signal quality
        rejection = self._check_signal_quality(signal)
        if rejection:
            return ProcessResult(
                passed=False,
                trade_params=None,
                rejection_reason=rejection,
                warnings=warnings,
            )

        # Step 2: Check portfolio limits
        self.portfolio_limits.update_equity(account_equity)
        limits_check = self.portfolio_limits.check_can_open_position(
            current_equity=account_equity,
            current_positions=current_positions,
        )
        if not limits_check.passed:
            return ProcessResult(
                passed=False,
                trade_params=None,
                rejection_reason=f"Portfolio limits: {limits_check.message}",
                warnings=warnings,
            )
        if limits_check.action == TradingAction.REDUCE_ONLY:
            warnings.append(f"Warning: {limits_check.message}")

        # Step 3: Calculate position size
        size_result = self.position_sizer.calculate_fixed_fractional(
            account_equity=account_equity,
            entry_price=signal.entry_price,
            stop_price=signal.stop_price,
            buying_power=buying_power,
        )

        if size_result.shares < 0.001:  # Effectively zero
            return ProcessResult(
                passed=False,
                trade_params=None,
                rejection_reason=f"Position too small: {size_result.shares:.4f} shares",
                warnings=warnings,
            )

        if size_result.capped_by_buying_power:
            warnings.append(f"Position capped by buying power: {size_result.shares:.4f} shares")

        if size_result.capped_by_max_position:
            warnings.append(f"Position capped by max position limit: {size_result.shares:.4f} shares")

        # Step 4: Build trade parameters
        trade_params = TradeParams(
            symbol=signal.symbol,
            side="buy" if signal.direction == SignalDirection.LONG else "sell",
            quantity=size_result.shares,
            entry_price=signal.entry_price,
            stop_price=signal.stop_price,
            target_price=signal.target_price,
            order_type="market",  # Use market for entries
            time_in_force="gtc" if signal.is_crypto else "day",
            signal=signal,
        )

        return ProcessResult(
            passed=True,
            trade_params=trade_params,
            rejection_reason=None,
            warnings=warnings,
        )

    def _check_signal_quality(self, signal: Signal) -> Optional[str]:
        """
        Check signal meets quality thresholds.

        Returns rejection reason or None if passed.
        """
        # Check strength
        if signal.strength < self.config.min_signal_strength:
            return f"Signal too weak: {signal.strength:.2f} < {self.config.min_signal_strength}"

        # Check R:R ratio
        if signal.risk_reward_ratio:
            if signal.risk_reward_ratio < self.config.min_risk_reward:
                return f"R:R too low: {signal.risk_reward_ratio:.2f} < {self.config.min_risk_reward}"

        # Check risk percent isn't too high
        if signal.risk_percent > 0.10:  # More than 10% stop distance
            return f"Stop too wide: {signal.risk_percent:.1%} risk"

        return None
