"""
Base classes for signal generation.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Literal, Optional

import pandas as pd


class SignalDirection(str, Enum):
    """Trade direction."""
    LONG = "long"
    SHORT = "short"


class SignalStrength(str, Enum):
    """Signal confidence level."""
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"


@dataclass
class Signal:
    """
    A trading signal generated by a strategy.

    Attributes:
        symbol: Asset symbol (e.g., "AAPL", "BTC/USD")
        direction: Long or short
        strength: Signal confidence (0.0 to 1.0)
        entry_price: Suggested entry price
        stop_price: Stop-loss price
        target_price: Optional take-profit price
        timeframe: Bar timeframe used (e.g., "1Hour", "1Day")
        strategy: Name of strategy that generated signal
        timestamp: When signal was generated
        metadata: Additional strategy-specific data
    """
    symbol: str
    direction: SignalDirection
    strength: float
    entry_price: float
    stop_price: float
    strategy: str
    timestamp: datetime = field(default_factory=datetime.now)
    target_price: Optional[float] = None
    timeframe: str = "1Day"
    metadata: dict = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal parameters."""
        if not 0 <= self.strength <= 1:
            raise ValueError(f"Strength must be 0-1, got {self.strength}")

        if self.direction == SignalDirection.LONG:
            if self.stop_price >= self.entry_price:
                raise ValueError("Long stop must be below entry")
            if self.target_price and self.target_price <= self.entry_price:
                raise ValueError("Long target must be above entry")
        else:
            if self.stop_price <= self.entry_price:
                raise ValueError("Short stop must be above entry")
            if self.target_price and self.target_price >= self.entry_price:
                raise ValueError("Short target must be below entry")

    @property
    def risk_amount(self) -> float:
        """Dollar risk per share."""
        return abs(self.entry_price - self.stop_price)

    @property
    def risk_percent(self) -> float:
        """Risk as percentage of entry."""
        return self.risk_amount / self.entry_price

    @property
    def reward_amount(self) -> Optional[float]:
        """Dollar reward per share if target set."""
        if not self.target_price:
            return None
        return abs(self.target_price - self.entry_price)

    @property
    def risk_reward_ratio(self) -> Optional[float]:
        """Reward to risk ratio."""
        reward = self.reward_amount
        if not reward:
            return None
        return reward / self.risk_amount

    @property
    def strength_category(self) -> SignalStrength:
        """Categorize signal strength."""
        if self.strength < 0.4:
            return SignalStrength.WEAK
        elif self.strength < 0.7:
            return SignalStrength.MODERATE
        else:
            return SignalStrength.STRONG

    @property
    def is_crypto(self) -> bool:
        """Check if symbol is crypto."""
        return "/" in self.symbol or self.symbol.endswith("USD")

    def to_dict(self) -> dict:
        """Serialize signal to dictionary."""
        return {
            "symbol": self.symbol,
            "direction": self.direction.value,
            "strength": self.strength,
            "strength_category": self.strength_category.value,
            "entry_price": self.entry_price,
            "stop_price": self.stop_price,
            "target_price": self.target_price,
            "risk_percent": round(self.risk_percent * 100, 2),
            "risk_reward": self.risk_reward_ratio,
            "timeframe": self.timeframe,
            "strategy": self.strategy,
            "timestamp": self.timestamp.isoformat(),
            "is_crypto": self.is_crypto,
            "metadata": self.metadata,
        }


class SignalGenerator(ABC):
    """
    Abstract base class for signal generators.

    Subclasses implement specific trading strategies.
    """

    def __init__(self, name: str):
        """
        Initialize signal generator.

        Args:
            name: Strategy name for identification
        """
        self.name = name

    @abstractmethod
    def generate(
        self,
        symbol: str,
        bars: pd.DataFrame,
        current_price: Optional[float] = None,
    ) -> Optional[Signal]:
        """
        Generate a trading signal from price data.

        Args:
            symbol: Asset symbol
            bars: OHLCV DataFrame with columns: open, high, low, close, volume
            current_price: Optional current price (if different from last close)

        Returns:
            Signal if conditions are met, None otherwise
        """
        pass

    @abstractmethod
    def should_exit(
        self,
        symbol: str,
        bars: pd.DataFrame,
        entry_price: float,
        direction: SignalDirection,
        current_price: Optional[float] = None,
    ) -> tuple[bool, Optional[str]]:
        """
        Check if an existing position should be exited.

        Args:
            symbol: Asset symbol
            bars: OHLCV DataFrame
            entry_price: Position entry price
            direction: Position direction
            current_price: Optional current price

        Returns:
            Tuple of (should_exit, reason)
        """
        pass

    def validate_bars(self, bars: pd.DataFrame, min_periods: int) -> bool:
        """
        Validate that bars DataFrame has required data.

        Args:
            bars: OHLCV DataFrame
            min_periods: Minimum required periods

        Returns:
            True if valid
        """
        required_columns = {"open", "high", "low", "close", "volume"}

        if bars is None or bars.empty:
            return False

        # Check columns (case-insensitive)
        bar_columns = {c.lower() for c in bars.columns}
        if not required_columns.issubset(bar_columns):
            return False

        if len(bars) < min_periods:
            return False

        return True

    def normalize_bars(self, bars: pd.DataFrame) -> pd.DataFrame:
        """
        Normalize bar column names to lowercase.

        Args:
            bars: OHLCV DataFrame

        Returns:
            DataFrame with lowercase column names
        """
        return bars.rename(columns={c: c.lower() for c in bars.columns})
